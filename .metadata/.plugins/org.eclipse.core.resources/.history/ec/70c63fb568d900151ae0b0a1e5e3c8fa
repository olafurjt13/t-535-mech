/*
 * spi_com.c
 *
 *  Created on: 20. feb. 2016
 *      Author: olafurjonthoroddsen
 */

#define DDR_SPI DDRB
#define SPI_MOSI DDB3
#define SPI_MISO DDB4
#define SPI_SCK DDB5
#define SPI_SS DDB2

#include "IMU_communication.h"
// including myUSART for debugging
#include "myUSART.h"

void SPI_MasterInit(void){
	// set MOSI, SCK and SS as output, all others are inputs.
	DDR_SPI = ( 1 << SPI_MOSI ) | ( 1 << SPI_SCK ) | ( 1 << SPI_SS );

	// SPI Control Register
	// SPE bit: SPI Enable
	// MSTR bit: Master select bit
	// SPR0 bit: Clock select bit, sets clock rate to Fosc/16
	SPCR = ( 1 << SPE ) | ( 1 << MSTR ) | ( 1 << SPR0 );
}

void SPI_MasterTransmit(char cData){
	// Start transmission
	// SPI Data Register, transfers data between register file and the SPI shift register
	SPDR = cData;

	// Wait for transmission to complete
	// SPI Status Register
	// SPIF bit: SPI Interrupt Flag, it is set when a serial transfer is complete
	while ( !( SPSR & ( 1 << SPIF ) ) ){};
}

void IMU_read_acc(char *accBuffer){


	char sendingRequest[27] = "Now sending request to IMU\n";
	char readingFromSPDR[18] = "Reading from SPDR\n";



	char *acc = (char *) &accBuffer;

	PORTB |= ( 1 << SPI_SS ); // Select the IMU as an SPI Slave


	// Send "read from acceleration output register" signal
	SPDR = 0b10101000;

	// Sending data request debug message
	for (unsigned char i =0; i <= 27; i++){
		USART_Transmit(sendingRequest[i]);
	}

	// Wait for the request to be sent
	while( !(SPSR & (1 << SPIF ) ) ){};

	for (unsigned char i = 0; i <= 6; i++){
			*acc = SPDR;
			acc++;
			//while( !(SPSR & (1 << SPIF ) ) ){};
			// Writing out the value of accBuffer to USART in hex format for debugging

			// This actually shows some data, at the moment, accBuffer is an 8bit variable
			// so it's definitely not the entire data package.
	}
	PORTB &= ~( 1 << SPI_SS );

}
